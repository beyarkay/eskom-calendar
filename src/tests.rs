use chrono::{DateTime, FixedOffset};

fn rfc3339(s: &str) -> DateTime<FixedOffset> {
    DateTime::parse_from_rfc3339(s).unwrap()
}

mod power_outage_to_event {
    use chrono::Utc;
    use icalendar::Component;

    use crate::{fmt::power_outage_to_event, structs::PowerOutage, tests::rfc3339};

    #[test]
    fn description_contains() {
        let e = power_outage_to_event(&PowerOutage {
            area_name: "test-name".to_owned(),
            stage: 2,
            start: rfc3339("2022-01-02T13:00:00+02:00"),
            finsh: rfc3339("2022-01-02T15:00:00+02:00"),
            source: "test-source".to_owned(),
        })
        .unwrap();
        let desc = e.get_description().unwrap();

        let should_contain_all = vec![
            "This event shows that there will be loadshedding on Sunday from 13:00 to Sunday at 15:00",
            "Generated by Boyd Kane's eskom-calendar: https://eskomcalendar.co.za/ec?calendar=test-name.ics.",
            "in the load shedding area test-name.",
            "National loadshedding information scraped from test-source.",
        ];
        for should_contain in should_contain_all {
            assert!(
                desc.contains(should_contain),
                "Description should contain:\n\"{should_contain}\"\nbut is:\n{desc}"
            );
        }
    }

    #[test]
    fn start_and_finsh_correct() {
        let start = rfc3339("2022-01-02T13:00:00+02:00");
        let finsh = rfc3339("2022-01-02T15:00:00+02:00");
        let e = power_outage_to_event(&PowerOutage {
            area_name: "test-name".to_owned(),
            stage: 2,
            start,
            finsh,
            source: "test-source".to_owned(),
        })
        .unwrap();
        assert_eq!(e.get_start().unwrap(), start.with_timezone(&Utc).into());
        assert_eq!(e.get_end().unwrap(), finsh.with_timezone(&Utc).into());
    }
}

mod check_for_overlaps {
    mod err_if {
        use std::path::PathBuf;
        use std::str::FromStr;

        use crate::structs::RawChange;
        use crate::{err_if_overlaps, structs::Change};

        #[test]
        fn first_is_subset_of_second() {
            let changes: Vec<Change> = vec![
                RawChange {
                    start: "2022-01-01T10:00:00".to_string(),
                    finsh: "2022-01-01T13:00:00".to_string(),
                    stage: 1,
                    source: "test_source".to_string(),
                    include_regex: None,
                    exclude_regex: None,
                    include: Some("coct".to_string()),
                    exclude: None,
                }
                .into(),
                RawChange {
                    start: "2022-01-01T11:00:00".to_string(),
                    finsh: "2022-01-01T12:00:00".to_string(),
                    stage: 1,
                    source: "test_source".to_string(),
                    include_regex: None,
                    exclude_regex: None,
                    include: Some("coct".to_string()),
                    exclude: None,
                }
                .into(),
            ];
            let paths = vec![
                PathBuf::from_str("generated/city-of-cape-town-area-1.csv").unwrap(),
                PathBuf::from_str("generated/city-of-cape-town-area-10.csv").unwrap(),
                PathBuf::from_str("generated/western-cape-stellenbosch.csv").unwrap(),
                PathBuf::from_str("generated/western-cape-darling.csv.csv").unwrap(),
            ];
            assert!(err_if_overlaps(&changes, &paths).is_err())
        }

        #[test]
        fn start2_lt_finsh1() {
            let changes: Vec<Change> = vec![
                RawChange {
                    start: "2022-01-01T10:00:00".to_string(),
                    finsh: "2022-01-01T12:00:00".to_string(),
                    stage: 1,
                    source: "test_source".to_string(),
                    include_regex: None,
                    exclude_regex: None,
                    include: Some("coct".to_string()),
                    exclude: None,
                }
                .into(),
                RawChange {
                    start: "2022-01-01T11:00:00".to_string(),
                    finsh: "2022-01-01T13:00:00".to_string(),
                    stage: 1,
                    source: "test_source".to_string(),
                    include_regex: None,
                    exclude_regex: None,
                    include: Some("coct".to_string()),
                    exclude: None,
                }
                .into(),
            ];
            let paths = vec![
                PathBuf::from_str("generated/city-of-cape-town-area-1.csv").unwrap(),
                PathBuf::from_str("generated/city-of-cape-town-area-10.csv").unwrap(),
                PathBuf::from_str("generated/western-cape-stellenbosch.csv").unwrap(),
                PathBuf::from_str("generated/western-cape-darling.csv.csv").unwrap(),
            ];
            assert!(err_if_overlaps(&changes, &paths).is_err())
        }
    }

    mod ok_if {
        use std::path::PathBuf;
        use std::str::FromStr;

        use crate::structs::RawChange;
        use crate::{err_if_overlaps, structs::Change};
        #[test]
        fn start2_lt_finsh1_but_different_regex() {
            let changes: Vec<Change> = vec![
                RawChange {
                    start: "2022-01-01T10:00:00".to_string(),
                    finsh: "2022-01-01T12:00:00".to_string(),
                    stage: 1,
                    source: "test_source".to_string(),
                    include_regex: None,
                    exclude_regex: None,
                    include: Some("coct".to_string()),
                    exclude: None,
                }
                .into(),
                RawChange {
                    start: "2022-01-01T11:00:00".to_string(),
                    finsh: "2022-01-01T13:00:00".to_string(),
                    stage: 1,
                    source: "test_source".to_string(),
                    include_regex: None,
                    exclude_regex: None,
                    include: None,
                    exclude: Some("coct".to_string()),
                }
                .into(),
            ];
            let paths = vec![
                PathBuf::from_str("generated/city-of-cape-town-area-1.csv").unwrap(),
                PathBuf::from_str("generated/city-of-cape-town-area-10.csv").unwrap(),
                PathBuf::from_str("generated/western-cape-stellenbosch.csv").unwrap(),
                PathBuf::from_str("generated/western-cape-darling.csv.csv").unwrap(),
            ];
            assert!(err_if_overlaps(&changes, &paths).is_ok())
        }
        #[test]
        fn ok_if_start_eq_finsh() {
            let changes: Vec<Change> = vec![
                RawChange {
                    start: "2022-01-01T10:00:00".to_string(),
                    finsh: "2022-01-01T12:30:00".to_string(),
                    stage: 1,
                    source: "test_source".to_string(),
                    include_regex: None,
                    exclude_regex: None,
                    include: Some("coct".to_string()),
                    exclude: None,
                }
                .into(),
                RawChange {
                    start: "2022-01-01T12:30:00".to_string(),
                    finsh: "2022-01-01T14:30:00".to_string(),
                    stage: 1,
                    source: "test_source".to_string(),
                    include_regex: None,
                    exclude_regex: None,
                    exclude: Some("coct".to_string()),
                    include: None,
                }
                .into(),
            ];
            let paths = vec![
                PathBuf::from_str("generated/city-of-cape-town-area-1.csv").unwrap(),
                PathBuf::from_str("generated/city-of-cape-town-area-10.csv").unwrap(),
                PathBuf::from_str("generated/western-cape-stellenbosch.csv").unwrap(),
                PathBuf::from_str("generated/western-cape-darling.csv.csv").unwrap(),
            ];
            assert!(err_if_overlaps(&changes, &paths).is_ok())
        }

        #[test]
        fn ok_if_mutually_exclusive() {
            let changes: Vec<Change> = vec![
                RawChange {
                    start: "2022-01-01T10:00:00".to_string(),
                    finsh: "2022-01-01T12:30:00".to_string(),
                    stage: 1,
                    source: "test_source".to_string(),
                    include_regex: None,
                    exclude_regex: None,
                    include: Some("coct".to_string()),
                    exclude: None,
                }
                .into(),
                RawChange {
                    start: "2022-01-01T10:00:00".to_string(),
                    finsh: "2022-01-01T12:30:00".to_string(),
                    stage: 1,
                    source: "test_source".to_string(),
                    include_regex: None,
                    exclude_regex: None,
                    exclude: Some("coct".to_string()),
                    include: None,
                }
                .into(),
            ];
            let paths = vec![
                PathBuf::from_str("generated/city-of-cape-town-area-1.csv").unwrap(),
                PathBuf::from_str("generated/city-of-cape-town-area-10.csv").unwrap(),
                PathBuf::from_str("generated/western-cape-stellenbosch.csv").unwrap(),
                PathBuf::from_str("generated/western-cape-darling.csv.csv").unwrap(),
            ];
            assert!(err_if_overlaps(&changes, &paths).is_ok())
        }

        #[test]
        fn ok_if_empty_vecs() {
            let changes = vec![];
            let paths = vec![];
            assert!(err_if_overlaps(&changes, &paths).is_ok())
        }
    }
}

mod write_sheddings_to_ics {
    use chrono::Duration;
    use icalendar::{CalendarDateTime, Component, DatePerhapsTime};

    use crate::tests::rfc3339;
    use crate::{structs::PowerOutage, write_sheddings_to_ics};
    use std::fs::remove_file;
    use std::path::PathBuf;

    #[test]
    fn doesnt_remove_sequential_events() {
        let mut power_outages = vec![
            // First the long event, then the 30 minute event
            PowerOutage {
                area_name: "test_area".to_string(),
                stage: 2,
                start: rfc3339("2023-05-29T18:00:00+02:00"),
                finsh: rfc3339("2023-05-29T20:00:00+02:00"),
                source: "test source".to_string(),
            },
            PowerOutage {
                area_name: "test_area".to_string(),
                stage: 4,
                start: rfc3339("2023-05-29T20:00:00+02:00"),
                finsh: rfc3339("2023-05-29T20:30:00+02:00"),
                source: "test source".to_string(),
            },
            // First the 30 minute event, then the long event
            PowerOutage {
                area_name: "test_area".to_string(),
                stage: 2,
                start: rfc3339("2023-05-29T10:00:00+02:00"),
                finsh: rfc3339("2023-05-29T10:30:00+02:00"),
                source: "test source".to_string(),
            },
            PowerOutage {
                area_name: "test_area".to_string(),
                stage: 4,
                start: rfc3339("2023-05-29T10:30:00+02:00"),
                finsh: rfc3339("2023-05-29T12:00:00+02:00"),
                source: "test source".to_string(),
            },
        ];

        let last_finsh = power_outages
            .iter()
            .max_by_key(|outage| outage.finsh)
            .map(|outage| outage.finsh);

        let calendar = write_sheddings_to_ics(
            &PathBuf::from("test.csv"),
            &mut power_outages,
            last_finsh,
            vec![],
            rfc3339("2099-01-01T00:00:00+02:00"),
        )
        .unwrap();

        let _ = remove_file("test.ics");

        let events: Vec<_> = calendar
            .components
            .iter()
            .filter_map(|c| c.as_event())
            // Filter out all the non-loadshedding events
            .filter(|e| {
                e.get_summary().map_or(false, |s| {
                    !s.contains("End of schedule") && !s.contains("Schedule expired")
                })
            })
            .collect();

        assert!(events.len() == power_outages.len());
    }

    #[test]
    fn removes_events_le_30_minutes() {
        let mut power_outages = vec![
            PowerOutage {
                area_name: "test_area".to_string(),
                stage: 4,
                start: rfc3339("2023-05-29T10:00:00+02:00"),
                finsh: rfc3339("2023-05-29T10:30:00+02:00"),
                source: "test source".to_string(),
            },
            PowerOutage {
                area_name: "test_area".to_string(),
                stage: 4,
                start: rfc3339("2023-05-29T18:00:00+02:00"),
                finsh: rfc3339("2023-05-29T18:10:00+02:00"),
                source: "test source".to_string(),
            },
            PowerOutage {
                area_name: "test_area".to_string(),
                stage: 4,
                start: rfc3339("2023-05-29T20:00:00+02:00"),
                finsh: rfc3339("2023-05-29T20:31:00+02:00"),
                source: "test source".to_string(),
            },
        ];

        let last_finsh = power_outages
            .iter()
            .max_by_key(|outage| outage.finsh)
            .map(|outage| outage.finsh);

        let calendar = write_sheddings_to_ics(
            &PathBuf::from("test.csv"),
            &mut power_outages,
            last_finsh,
            vec![],
            rfc3339("2099-01-01T00:00:00+02:00"),
        )
        .unwrap();
        let _ = remove_file("test.ics");

        let events: Vec<_> = calendar
            .components
            .iter()
            .filter_map(|c| c.as_event())
            .collect();

        let min_duration = Duration::minutes(30);

        assert!(events.iter().all(|e| {
            if let DatePerhapsTime::DateTime(CalendarDateTime::Utc(start)) = e.get_start().unwrap()
            {
                if let DatePerhapsTime::DateTime(CalendarDateTime::Utc(finsh)) =
                    e.get_end().unwrap()
                {
                    return finsh - start > min_duration;
                }
            }
            false
        }));
    }
}

mod gen_datetimes {
    use crate::{structs::Recurrence, tests::rfc3339};
    use chrono::{Datelike, NaiveTime};

    use crate::gen_datetimes;

    #[test]
    fn dom_different_to_start_date() {
        let start_dt = rfc3339("2022-01-02T00:00:00+02:00");
        let finsh_dt = rfc3339("2022-01-02T01:00:00+02:00");
        let dor = 1;
        let recurrence = Recurrence::Monthly;
        let start_time = NaiveTime::from_hms_opt(23, 30, 0).unwrap();
        let finsh_time = NaiveTime::from_hms_opt(0, 30, 0).unwrap();
        let datetimes = gen_datetimes(start_dt, finsh_dt, dor, recurrence, start_time, finsh_time);
        assert_eq!(
            datetimes,
            vec![(
                rfc3339("2022-01-02T00:00:00+02:00"),
                rfc3339("2022-01-02T00:30:00+02:00")
            )]
        );
    }

    #[test]
    fn crosses_finsh_boundary() {
        let start_dt = rfc3339("2022-01-01T10:00:00+02:00");
        let finsh_dt = rfc3339("2022-01-01T20:00:00+02:00");
        let dor = 1;
        let recurrence = Recurrence::Monthly;
        let start_time = NaiveTime::from_hms_opt(19, 0, 0).unwrap();
        let finsh_time = NaiveTime::from_hms_opt(21, 0, 0).unwrap();
        let datetimes = gen_datetimes(start_dt, finsh_dt, dor, recurrence, start_time, finsh_time);
        assert_eq!(
            datetimes,
            vec![(
                rfc3339("2022-01-01T19:00:00+02:00"),
                rfc3339("2022-01-01T20:00:00+02:00")
            )]
        );
    }

    #[test]
    fn crosses_start_boundary() {
        let start_dt = rfc3339("2022-01-01T10:00:00+02:00");
        let finsh_dt = rfc3339("2022-01-01T20:00:00+02:00");
        let dor = 1;
        let recurrence = Recurrence::Monthly;
        let start_time = NaiveTime::from_hms_opt(9, 0, 0).unwrap();
        let finsh_time = NaiveTime::from_hms_opt(11, 0, 0).unwrap();
        let datetimes = gen_datetimes(start_dt, finsh_dt, dor, recurrence, start_time, finsh_time);
        assert_eq!(
            datetimes,
            vec![(
                rfc3339("2022-01-01T10:00:00+02:00"),
                rfc3339("2022-01-01T11:00:00+02:00")
            )]
        );
    }

    /// The date of recurrence isn't allowed to be greater than the period length
    #[should_panic]
    #[test]
    fn dor_greater_than_period() {
        let _ = gen_datetimes(
            rfc3339("2023-02-18T00:00:00+02:00"),
            rfc3339("2023-06-11T00:00:00+02:00"),
            2,
            Recurrence::Periodic {
                offset: rfc3339("2023-02-18T00:00:00+02:00").date_naive(),
                period: 1,
            },
            NaiveTime::from_hms_opt(12, 0, 0).unwrap(),
            NaiveTime::from_hms_opt(14, 0, 0).unwrap(),
        );
    }

    #[test]
    fn nelson_mandela_bay_end() {
        // Example taken from https://nelsonmandelabay.gov.za/page/loadshedding
        let start_dt = rfc3339("2023-02-18T00:00:00+02:00");
        let finsh_dt = rfc3339("2023-06-11T00:00:00+02:00");
        let dor = 19;
        let recurrence = Recurrence::Periodic {
            offset: rfc3339("2023-02-18T00:00:00+02:00").date_naive(),
            period: 19,
        };
        let start_time = NaiveTime::from_hms_opt(12, 0, 0).unwrap();
        let finsh_time = NaiveTime::from_hms_opt(14, 0, 0).unwrap();
        let actual = gen_datetimes(start_dt, finsh_dt, dor, recurrence, start_time, finsh_time);
        let expected = vec![
            (
                rfc3339("2023-03-08T12:00:00+02:00"),
                rfc3339("2023-03-08T14:00:00+02:00"),
            ),
            (
                rfc3339("2023-03-27T12:00:00+02:00"),
                rfc3339("2023-03-27T14:00:00+02:00"),
            ),
            (
                rfc3339("2023-04-15T12:00:00+02:00"),
                rfc3339("2023-04-15T14:00:00+02:00"),
            ),
            (
                rfc3339("2023-05-04T12:00:00+02:00"),
                rfc3339("2023-05-04T14:00:00+02:00"),
            ),
            (
                rfc3339("2023-05-23T12:00:00+02:00"),
                rfc3339("2023-05-23T14:00:00+02:00"),
            ),
            (
                rfc3339("2023-06-11T12:00:00+02:00"),
                rfc3339("2023-06-11T14:00:00+02:00"),
            ),
        ];
        for (i, (expected_item, actual_item)) in actual.iter().zip(expected.iter()).enumerate() {
            assert_eq!(expected_item, actual_item, "Failed at index {}", i);
        }
    }

    #[test]
    fn nelson_mandela_bay_start() {
        // Example taken from https://nelsonmandelabay.gov.za/page/loadshedding
        let start_dt = rfc3339("2023-02-18T00:00:00+02:00");
        let finsh_dt = rfc3339("2023-06-11T00:00:00+02:00");
        let dor = 1;
        let recurrence = Recurrence::Periodic {
            offset: start_dt.date_naive(),
            period: 19,
        };
        let start_time = NaiveTime::from_hms_opt(12, 0, 0).unwrap();
        let finsh_time = NaiveTime::from_hms_opt(14, 0, 0).unwrap();
        let actual = gen_datetimes(start_dt, finsh_dt, dor, recurrence, start_time, finsh_time);
        let expected = vec![
            (
                rfc3339("2023-02-18T12:00:00+02:00"),
                rfc3339("2023-02-18T14:00:00+02:00"),
            ),
            (
                rfc3339("2023-03-09T12:00:00+02:00"),
                rfc3339("2023-03-09T14:00:00+02:00"),
            ),
            (
                rfc3339("2023-03-28T12:00:00+02:00"),
                rfc3339("2023-03-28T14:00:00+02:00"),
            ),
            (
                rfc3339("2023-04-16T12:00:00+02:00"),
                rfc3339("2023-04-16T14:00:00+02:00"),
            ),
            (
                rfc3339("2023-05-05T12:00:00+02:00"),
                rfc3339("2023-05-05T14:00:00+02:00"),
            ),
            (
                rfc3339("2023-05-24T12:00:00+02:00"),
                rfc3339("2023-05-24T14:00:00+02:00"),
            ),
        ];
        for (i, (expected_item, actual_item)) in actual.iter().zip(expected.iter()).enumerate() {
            assert_eq!(expected_item, actual_item, "Failed at index {}", i);
        }
    }

    #[test]
    fn first_day_of_week() {
        let start_dt = rfc3339("2022-01-01T00:00:00+02:00");
        let finsh_dt = rfc3339("2022-02-01T00:00:00+02:00");
        let dor = 1; // Sunday
        let recurrence = Recurrence::Weekly;
        let start_time = NaiveTime::from_hms_opt(12, 0, 0).unwrap();
        let finsh_time = NaiveTime::from_hms_opt(14, 0, 0).unwrap();
        let datetimes = gen_datetimes(start_dt, finsh_dt, dor, recurrence, start_time, finsh_time);
        // Assert that the dates are all on the correct day of the recurrence
        for (s, f) in &datetimes {
            assert_eq!(s.weekday().number_from_monday(), dor as u32);
            assert_eq!(f.weekday().number_from_monday(), dor as u32);
        }
        // Assert that they're the correct actual day
        assert_eq!(
            datetimes,
            vec![
                (
                    rfc3339("2022-01-03T12:00:00+02:00"),
                    rfc3339("2022-01-03T14:00:00+02:00")
                ),
                (
                    rfc3339("2022-01-10T12:00:00+02:00"),
                    rfc3339("2022-01-10T14:00:00+02:00")
                ),
                (
                    rfc3339("2022-01-17T12:00:00+02:00"),
                    rfc3339("2022-01-17T14:00:00+02:00")
                ),
                (
                    rfc3339("2022-01-24T12:00:00+02:00"),
                    rfc3339("2022-01-24T14:00:00+02:00")
                ),
                (
                    rfc3339("2022-01-31T12:00:00+02:00"),
                    rfc3339("2022-01-31T14:00:00+02:00")
                )
            ]
        );
    }

    #[test]
    fn last_day_of_week() {
        let start_dt = rfc3339("2022-01-01T00:00:00+02:00");
        let finsh_dt = rfc3339("2022-02-01T00:00:00+02:00");
        let dor = 7; // Sunday
        let recurrence = Recurrence::Weekly;
        let start_time = NaiveTime::from_hms_opt(12, 0, 0).unwrap();
        let finsh_time = NaiveTime::from_hms_opt(14, 0, 0).unwrap();
        let datetimes = gen_datetimes(start_dt, finsh_dt, dor, recurrence, start_time, finsh_time);
        // Assert that the dates are all on the correct day of the recurrence
        for (s, f) in &datetimes {
            assert_eq!(s.weekday().number_from_monday(), dor as u32);
            assert_eq!(f.weekday().number_from_monday(), dor as u32);
        }
        // Assert that they're the correct actual day
        assert_eq!(
            datetimes,
            vec![
                (
                    rfc3339("2022-01-02T12:00:00+02:00"),
                    rfc3339("2022-01-02T14:00:00+02:00")
                ),
                (
                    rfc3339("2022-01-09T12:00:00+02:00"),
                    rfc3339("2022-01-09T14:00:00+02:00")
                ),
                (
                    rfc3339("2022-01-16T12:00:00+02:00"),
                    rfc3339("2022-01-16T14:00:00+02:00")
                ),
                (
                    rfc3339("2022-01-23T12:00:00+02:00"),
                    rfc3339("2022-01-23T14:00:00+02:00")
                ),
                (
                    rfc3339("2022-01-30T12:00:00+02:00"),
                    rfc3339("2022-01-30T14:00:00+02:00")
                )
            ]
        );
    }

    /// Assert that a monthly recurrence on the 31st of each month doesn't generate dates like
    /// the 31st of February.
    #[test]
    fn last_day_of_month() {
        let start_dt = rfc3339("2022-01-01T00:00:00+02:00");
        let finsh_dt = rfc3339("2023-01-01T00:00:00+02:00");
        let dor = 31;
        let recurrence = Recurrence::Monthly;
        let start_time = NaiveTime::from_hms_opt(12, 0, 0).unwrap();
        let finsh_time = NaiveTime::from_hms_opt(14, 0, 0).unwrap();
        let datetimes = gen_datetimes(start_dt, finsh_dt, dor, recurrence, start_time, finsh_time);
        assert_eq!(
            datetimes,
            vec![
                (
                    rfc3339("2022-01-31T12:00:00+02:00"),
                    rfc3339("2022-01-31T14:00:00+02:00")
                ),
                (
                    rfc3339("2022-03-31T12:00:00+02:00"),
                    rfc3339("2022-03-31T14:00:00+02:00")
                ),
                (
                    rfc3339("2022-05-31T12:00:00+02:00"),
                    rfc3339("2022-05-31T14:00:00+02:00")
                ),
                (
                    rfc3339("2022-07-31T12:00:00+02:00"),
                    rfc3339("2022-07-31T14:00:00+02:00")
                ),
                (
                    rfc3339("2022-08-31T12:00:00+02:00"),
                    rfc3339("2022-08-31T14:00:00+02:00")
                ),
                (
                    rfc3339("2022-10-31T12:00:00+02:00"),
                    rfc3339("2022-10-31T14:00:00+02:00")
                ),
                (
                    rfc3339("2022-12-31T12:00:00+02:00"),
                    rfc3339("2022-12-31T14:00:00+02:00")
                )
            ]
        );
    }

    #[test]
    fn multiple_months() {
        let start_dt = rfc3339("2022-01-01T00:00:00+02:00");
        let finsh_dt = rfc3339("2023-01-01T00:00:00+02:00");
        let dor = 1;
        let recurrence = Recurrence::Monthly;
        let start_time = NaiveTime::from_hms_opt(12, 0, 0).unwrap();
        let finsh_time = NaiveTime::from_hms_opt(14, 0, 0).unwrap();
        let datetimes = gen_datetimes(start_dt, finsh_dt, dor, recurrence, start_time, finsh_time);
        assert_eq!(
            datetimes,
            vec![
                (
                    rfc3339("2022-01-01T12:00:00+02:00"),
                    rfc3339("2022-01-01T14:00:00+02:00")
                ),
                (
                    rfc3339("2022-02-01T12:00:00+02:00"),
                    rfc3339("2022-02-01T14:00:00+02:00")
                ),
                (
                    rfc3339("2022-03-01T12:00:00+02:00"),
                    rfc3339("2022-03-01T14:00:00+02:00")
                ),
                (
                    rfc3339("2022-04-01T12:00:00+02:00"),
                    rfc3339("2022-04-01T14:00:00+02:00")
                ),
                (
                    rfc3339("2022-05-01T12:00:00+02:00"),
                    rfc3339("2022-05-01T14:00:00+02:00")
                ),
                (
                    rfc3339("2022-06-01T12:00:00+02:00"),
                    rfc3339("2022-06-01T14:00:00+02:00")
                ),
                (
                    rfc3339("2022-07-01T12:00:00+02:00"),
                    rfc3339("2022-07-01T14:00:00+02:00")
                ),
                (
                    rfc3339("2022-08-01T12:00:00+02:00"),
                    rfc3339("2022-08-01T14:00:00+02:00")
                ),
                (
                    rfc3339("2022-09-01T12:00:00+02:00"),
                    rfc3339("2022-09-01T14:00:00+02:00")
                ),
                (
                    rfc3339("2022-10-01T12:00:00+02:00"),
                    rfc3339("2022-10-01T14:00:00+02:00")
                ),
                (
                    rfc3339("2022-11-01T12:00:00+02:00"),
                    rfc3339("2022-11-01T14:00:00+02:00")
                ),
                (
                    rfc3339("2022-12-01T12:00:00+02:00"),
                    rfc3339("2022-12-01T14:00:00+02:00")
                )
            ]
        );
    }

    #[test]
    fn crosses_year_boundary() {
        let start_dt = rfc3339("2022-12-31T00:00:00+02:00");
        let finsh_dt = rfc3339("2023-01-02T00:00:00+02:00");
        let dor = 1;
        let recurrence = Recurrence::Monthly;
        let start_time = NaiveTime::from_hms_opt(12, 0, 0).unwrap();
        let finsh_time = NaiveTime::from_hms_opt(14, 0, 0).unwrap();
        let datetimes = gen_datetimes(start_dt, finsh_dt, dor, recurrence, start_time, finsh_time);
        assert_eq!(
            datetimes,
            vec![(
                rfc3339("2023-01-01T12:00:00+02:00"),
                rfc3339("2023-01-01T14:00:00+02:00")
            ),]
        );
    }

    #[test]
    fn crosses_month_boundary() {
        let start_dt = rfc3339("2022-01-31T00:00:00+02:00");
        let finsh_dt = rfc3339("2022-02-02T00:00:00+02:00");
        let dor = 1;
        let recurrence = Recurrence::Monthly;
        let start_time = NaiveTime::from_hms_opt(12, 0, 0).unwrap();
        let finsh_time = NaiveTime::from_hms_opt(14, 0, 0).unwrap();
        let datetimes = gen_datetimes(start_dt, finsh_dt, dor, recurrence, start_time, finsh_time);
        assert_eq!(
            datetimes,
            vec![(
                rfc3339("2022-02-01T12:00:00+02:00"),
                rfc3339("2022-02-01T14:00:00+02:00")
            ),]
        );
    }

    #[test]
    fn crosses_midnight() {
        let start_dt = rfc3339("2022-01-01T00:00:00+02:00");
        let finsh_dt = rfc3339("2022-04-01T00:00:00+02:00");
        let dor = 1;
        let recurrence = Recurrence::Monthly;
        let start_time = NaiveTime::from_hms_opt(22, 0, 0).unwrap();
        let finsh_time = NaiveTime::from_hms_opt(0, 30, 0).unwrap();
        let datetimes = gen_datetimes(start_dt, finsh_dt, dor, recurrence, start_time, finsh_time);
        assert_eq!(
            datetimes,
            vec![
                (
                    rfc3339("2022-01-01T22:00:00+02:00"),
                    rfc3339("2022-01-02T00:30:00+02:00")
                ),
                (
                    rfc3339("2022-02-01T22:00:00+02:00"),
                    rfc3339("2022-02-02T00:30:00+02:00")
                ),
                (
                    rfc3339("2022-03-01T22:00:00+02:00"),
                    rfc3339("2022-03-02T00:30:00+02:00")
                )
            ]
        );
    }
}
